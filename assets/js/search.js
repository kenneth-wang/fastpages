
var documents = [{
    "id": 0,
    "url": "https://kenneth-wang.github.io/404.html",
    "title": "",
    "body": " 404 Page not found :(  The requested page could not be found. "
    }, {
    "id": 1,
    "url": "https://kenneth-wang.github.io/about/",
    "title": "",
    "body": " I am a graduate of NUS Business School and consider myself as an outgoing and highly driven individual with a strong emphasis on teamwork. Currently working on pre-built AI solutions (“Bricks”) for AI Makerspace, a national platform offered by AI Singapore to help SMEs and Start-ups accelerate the adoption of AI in Singapore. Active contributor to the development of information retrieval engine and auto labeling bricks. I have a strong interest in Natural Language Processing and am currently seeking opportunities to be at the intersection of Finance and AI. Looking forward to connecting with like-minded individuals and learn something new every day! "
    }, {
    "id": 2,
    "url": "https://kenneth-wang.github.io/categories/",
    "title": "Tags",
    "body": "Contents: {% if site. categories. size &gt; 0 %} {% for category in site. categories %} {% capture category_name %}{{ category | first }}{% endcapture %} {{ category_name }}{% endfor %}{% endif %} {% for category in site. categories %}  {% capture category_name %}{{ category | first }}{% endcapture %} &lt;h3 id = {{ category_name }} &gt;&lt;i class= fas fa-tags category-tags-icon &gt;&lt;/i&gt;&lt;/i&gt; {{ category_name }}&lt;/h3&gt;&lt;a name= {{ category_name | slugize }} &gt;&lt;/a&gt;{% for post in site. categories[category_name] %}{%- assign date_format = site. minima. date_format | default:  %b %-d, %Y  -%}&lt;article class= archive-item &gt; &lt;p class= post-meta post-meta-title &gt;&lt;a class= page-meta  href= {{ site. baseurl }}{{ post. url }} &gt;{{post. title}}&lt;/a&gt; • {{ post. date | date: date_format }}&lt;/p&gt;&lt;/article&gt;{% endfor %} {% endfor %}"
    }, {
    "id": 3,
    "url": "https://kenneth-wang.github.io/images/copied_from_nb/",
    "title": "",
    "body": "WarningDo not manually save images into this folder. This is used by GitHub Actions to automatically copy images.  Any images you save into this folder could be deleted at build time. "
    }, {
    "id": 4,
    "url": "https://kenneth-wang.github.io/2020/03/03/_03_01_Smartie_Slackbot.html",
    "title": "Smartie - Your personalized stock watchlist",
    "body": "2020/03/03 -           There is an abundance of websites/news app that are offering stock watchlists for users to get timely updates. However it may be difficult for us to find one that is customizable and able to offer information apart from price movements. By the end of this post, I hope you can create your own Slack bot that gives you personalized information based on your needs. We will be working through the steps together to create a bot that sends you a list of S&amp;P500 stocks and their Relative Strength Index (RSI) on a periodic basis. You can always amend the code if you are interested in other stock information. In terms of deployment, the app with all of its dependencies will be packaged into a docker image and be pushed to Docker Hub, a service provided by Docker to share docker images. With the docker image, we will build a docker container that includes everything we need to run the app on a server. For this example, I will be using Digital Ocean to host the app. Ok let's get started! Project directory structure&#182;The files that we will be referring to can be found here and in this section, I will illustrate how the different files will fit together. Before delving into the code and to avoid any confusion, let's look at how the files are arranged. The sp500_stocks. csv file contains the current constituents of the popular S&amp;P500 stock index. The classes/functions that we will be building can be found in stock. py and app. py.  The rest of the files will be used to build the docker image/container for us to deploy on the server.       smartie/_______ data/___________ sp500_stocks. csv_______ src/___________ __init__. py___________ stock. py_______ app. py_______ conda. yml_______ Dockerfile_______ credentials. py # To be created by user_______ env. list # To be created by user_______ run. sh    Generating the credentials we need&#182;Before we are able to send any stock related information to a Slack channel, we will need to retrieve some credentials/IDs from Alpha Vantage and Slack. We will store them in a credentials. py file to be used with this notebook. Click on the links below to setup the credentials. ALPHA_VANTAGE_KEY: We will be using Alpha Vantage to retrieve the stock prices. Ever since Yahoo decided to discontinue their finance API service,it has been difficult for many users to find a new platform to access pricing data for free. Alpha Vantage offers the data for free, however if you are looking to create a high-frequency trading bot, you will probably find yourself disappointed. There is a limit of 5 API-requests per minute and 500 API requests per day. However, you can always subscribe to their paid services if you are looking to remove these limits. API token: This is required to use Slack's API service for your selected Development Slack Workspace (channel). Follow the instructions in the link to obtain an access key. Channel ID: This is required to access the channel you have attached your app to. Slack Bot Token: Credentials required to use the bot associated with your channel. This can be accessed via the Slack API App webpage. Slack Signing Secret: A unique string that Slack shares with us. When sending a request, the signing secret is combined with the body using a HMAC-SHA256 keyed hash. The resulting signature is unique and is used by Slack to verify that the request is actually sent by you. This can be found under  Basic Information  on the side bar of the Slack API webpage.  Once you have the credentials, add it into your credentials. py file. Refer to below for an example.       SLACK_API_TOKEN=&quot;xoxp-945736515923-959414305302. . . . &quot;CHANNEL_ID=&quot;CU. . . &quot;SLACK_BOT_TOKEN=&quot;xoxb-945736515923-957048941172. . . . . &quot;SLACK_SIGNING_SECRET=&quot;88a3424d. . . . . &quot;ALPHA_VANTAGE_KEY=&quot;E1UR. . . . &quot;    Using Google Colab&#182;If you are running the notebook using Google Colab, remember to mount the directory that you are working from.       %%capturefrom google. colab import drivedrive. mount(&#39;/content/gdrive/&#39;)%cd /content/gdrive/My Drive/Colab Notebooks/ssh_files/smartie_slackbotimport syssys. path. append(&quot;. &quot;)  Go to this URL in a browser: https://accounts. google. com/o/oauth2/auth?client_id=947318989803-6bn6qk8qdgf4n4g3pfee6491hc0brc4i. apps. googleusercontent. com&amp;redirect_uri=urn%3aietf%3awg%3aoauth%3a2. 0%3aoob&amp;response_type=code&amp;scope=email%20https%3a%2f%2fwww. googleapis. com%2fauth%2fdocs. test%20https%3a%2f%2fwww. googleapis. com%2fauth%2fdrive%20https%3a%2f%2fwww. googleapis. com%2fauth%2fdrive. photos. readonly%20https%3a%2f%2fwww. googleapis. com%2fauth%2fpeopleapi. readonlyEnter your authorization code:··········        from credentials import SLACK_API_TOKEN, CHANNEL_ID, SLACK_BOT_TOKEN, \            SLACK_SIGNING_SECRET, ALPHA_VANTAGE_KEY    Requirements&#182;Not to forget, we need to install the dependencies. . .       %%capture!pip install alpha-vantage==2. 1. 3!pip install beautiful soup4==4. 8. 2!pip install slack==0. 0. 2!pip install slackclient==2. 5. 0!pip install slackeventsapi==2. 1. 0!pip install websocket-client==0. 57. 0    . . . and import the python packages that we will be using       import requestsimport timeimport pandas as pdimport numpy as npimport slackimport ssl as ssl_libimport certifiimport datetimefrom bs4 import BeautifulSoupfrom alpha_vantage. timeseries import TimeSeriesfrom pandas. tseries. holiday import USFederalHolidayCalendar as calendarfrom flask import Flaskfrom slackeventsapi import SlackEventAdapter    Retrieving the S&amp;P500 component stocks from wikipedia&#182;To get a list of S&amp;P500 component stocks, we will scrape a table from a wikipedia webpage. Whenever you require an updated list, you can revisit this function.       def get_sp500_stocks_wiki(url=None):  &quot;&quot;&quot;  Scapes a wikipedia web page to retrieve a table of S&amp;P500 component stocks.   Use this function if you require an updated table.   args:  ------    url: (str) url leading to the wikipedia web page  Return:  ------    df: (pd. DataFrame) a copy of the wikipedia table   &quot;&quot;&quot;  website_url = requests. get(url)  soup = BeautifulSoup(website_url. text, &#39;lxml&#39;)  my_table = soup. find(&#39;table&#39;, {&#39;class&#39;: &#39;wikitable sortable&#39;})  my_table  table_rows = my_table. find_all(&#39;tr&#39;)  data = []  for row in table_rows:    data. append([t. text. strip() for t in row. find_all(&#39;td&#39;)])  df = pd. DataFrame(data[1:], columns=[&#39;Ticker&#39;, &#39;Security&#39;, &#39;SEC_Filings&#39;,                     &#39;GICS&#39;, &#39;GICS_Sub&#39;, &#39;HQ&#39;,                     &#39;Date_First_Added&#39;, &#39;CIK&#39;, &#39;Founded&#39;])  return df    Although we have scrapped the whole table, we are mainly interested in the tickers, security name and GICS classification.       sp500_stocks_df = get_sp500_stocks_wiki(&quot;https://en. wikipedia. org/wiki/List_of_S%26P_500_companies&quot;)sp500_stocks_df. to_csv(&#39;. /data/sp500_stocks. csv&#39;, index=False)sp500_stocks_df[[&#39;Ticker&#39;, &#39;Security&#39;, &#39;GICS&#39; ]]. head(5)           Ticker   Security   GICS         0   MMM   3M Company   Industrials       1   ABT   Abbott Laboratories   Health Care       2   ABBV   AbbVie Inc.    Health Care       3   ABMD   ABIOMED Inc   Health Care       4   ACN   Accenture plc   Information Technology     Let's start coding our Slack bot!&#182;I have named my Slack bot as Smartie, and I have a created a class with a similar name. The class serves three main purposes: To retrieve the RSI of the stocks that we are interested in get_stocks_rsi. To convert the RSI readings into strings that can be read as texts on the Slack app get_rsi_string. To package the strings above into Slack compatible blocks and send them to our Slack channel with the relevant meta information get_message_payload_stock, get_message_payload. Fret not, if the class looks overwhelming! We will go through each of the methods so that you are able amend this class for your own use case.       class Smartie:  &quot;&quot;&quot;Slack app that sends stock analysis results for the day. &quot;&quot;&quot;  def __init__(self, channel):    self. channel = channel    self. username = &quot;smartie&quot;    self. reaction_task_completed = False    self. pin_task_completed = False    self. DIVIDER_BLOCK = {&quot;type&quot;: &quot;divider&quot;}  def get_stocks_rsi(self, rsi_n=14, stocks_n=100,            file_path=&#39;. /data/sp500_stocks. csv&#39;,            ind_excld=[&#39;Health Care&#39;, &#39;Utilities&#39;, &#39;Energy&#39;]):    &quot;&quot;&quot;    Calculates the Relative Strength Index (RSI) for a group of stocks    args:    ------      rsi_n: (list) size of rsi look-back period      stocks_n: (int) number of stocks to retrieve the rsi for      file_path (str): path leading to csv file of S&amp;P500 component                stocks      ind_excld: (list) GICS Sector industries to be excluded    Return:    ------      df_rsi: (pd. DataFrame) returns the rsi reading for the list of           stocks and whether the 30/70 levels have been breached    &quot;&quot;&quot;    sp500_stocks_df = get_sp500_stocks_file(file_path=file_path)    sp500_stocks_df_excld = filter_stocks_industry(sp500_stocks_df,                            ind_excld=ind_excld)    sp500_stocks_df_excld = sp500_stocks_df_excld. head(stocks_n)    info, symbols = get_stock_price(sp500_stocks_df_excld)    sp500_stocks_price_df = get_stock_price_df(info, symbols)    symbols = sp500_stocks_price_df[&#39;Symbol&#39;]. unique()    rsi_l = []    status_l = []    for s in symbols:      s_df = sp500_stocks_price_df[sp500_stocks_price_df[&#39;Symbol&#39;] == s]      closep = np. array(s_df[&#39;Close&#39;]. tolist())      closep = closep. astype(np. float)      rsi = get_rsi(closep, n=rsi_n)      if rsi[-1] &gt;=70:        status = &#39;Above 70&#39;      elif rsi[-1] &lt;= 30:        status = &#39;Below 30&#39;      else:        status = &#39;Normal&#39;      rsi_l. append(round(rsi[-1], 1))      status_l. append(status)    df_rsi = pd. DataFrame(zip(symbols, rsi_l, status_l),               columns=[&#39;Symbols&#39;, &#39;RSI&#39;, &#39;Status&#39;])    return df_rsi  def get_rsi_string(self, df_rsi, head_n=20, tail_n=20):    &quot;&quot;&quot;    Converts the RSI readings into strings to be displayed in Slack    args:    ------      df_rsi: (pd. DataFrame) the rsi readings for a list of           stocks and whether the 30/70 levels have been breached      head_n: (int) number of top ranked stocks (based on rsi) reading          to be displayed in Slack      tail_n: (int) number of bottom ranked stocks (based on rsi) reading           to be displayed in Slack    Return:    ------      top_str: (str) concatenated string for top ranked stocks&#39; rsi           reading      btm_str: (str) concatenated string for bottom ranked stocks&#39; rsi           reading    &quot;&quot;&quot;    df_rsi = df_rsi. sort_values(&#39;RSI&#39;,ascending=False)    df_top = df_rsi. head(head_n)    df_btm = df_rsi. tail(tail_n)    top_symbols = df_top[&#39;Symbols&#39;]. tolist()    btm_symbols = df_btm[&#39;Symbols&#39;]. tolist()    top_rsi = df_top[&#39;RSI&#39;]. tolist()    btm_rsi = df_btm[&#39;RSI&#39;]. tolist()    top_l = list(zip(top_symbols, top_rsi))    btm_l = list(zip(btm_symbols, btm_rsi))    top_str = &quot;&quot;    for el in top_l:      top_str = top_str + str(el[0]) + &quot; &quot; + str(el[1]) + &quot;\n&quot;    btm_str = &quot;&quot;    for el in btm_l:      btm_str = btm_str + str(el[0]) + &quot; &quot; + str(el[1]) + &quot;\n&quot;    return top_str, btm_str  def _get_text_block(self, string):    &quot;&quot;&quot;    Helper function for get_message_payload_stock method.     Used to convert a string into a slack formatted text block.     args:    ------      string: (str) concatenated string for the top or bottom ranked          stocks&#39; rsi reading    Return:    ------      dictionary containing the correctly formatted text block to be       displayed in slack    &quot;&quot;&quot;    return {&quot;type&quot;: &quot;section&quot;, &quot;text&quot;: {&quot;type&quot;: &quot;mrkdwn&quot;, &quot;text&quot;: string}}  def get_message_payload_stock(self, top_str, btm_str):    &quot;&quot;&quot;    Used to create a message payload to send stock rsi readings    args:    ------      top_str: (str) concatenated string for the top ranked stocks&#39;           rsi readings      bottom_str: (str) concatenated string for the bottom ranked            stocks&#39; rsi readings    Return:    ------      dictionary containing payload (stock rsi readings) to be sent      using Slack&#39;s API    &quot;&quot;&quot;    return {      &quot;channel&quot;: self. channel,      &quot;username&quot;: self. username,      &quot;blocks&quot;: [        self. _get_text_block(top_str),        self. DIVIDER_BLOCK,        self. _get_text_block(btm_str)      ],    }  def get_message_payload(self, string):    &quot;&quot;&quot;    Used to create a message payload to send simple text messages    args:    ------      string: (str) string to be sent using Slack&#39;s API    Return:    ------      dictionary containing payload (simple text messages) to be sent      using Slack&#39;s API.     &quot;&quot;&quot;    return {      &quot;channel&quot;: self. channel,      &quot;username&quot;: self. username,      &quot;text&quot;: string    }    Retrieving the RSI readings - overbought or oversold?&#182;: RSI was developed as a momentum oscillator that measures the speed and change of price movements. The index mainly oscillates between 0 to 100 and a stock is considered as overbought when it is above 70 and oversold when below 30. This is a relatively simple indicator and you can always substitute RSI for other indicators. Our aim with get_stocks_rsi is to retrieve a dataframe with stock names, their RSI readings and whether they are within the overbought (&gt;70), oversold (&lt;30), normal ranges. I have illustrated the output of this function using 10 stocks selected from a pool of companies.       from src. stock import get_sp500_stocks_wiki, get_sp500_stocks_file, \           filter_stocks_industry, get_stock_price, \           get_stock_price_df, get_rsi          def get_stocks_rsi(rsi_n=14, stocks_n=100, file_path=&#39;. /data/sp500_stocks. csv&#39;,          ind_excld=[&#39;Health Care&#39;, &#39;Utilities&#39;, &#39;Energy&#39;]):  &quot;&quot;&quot;  Calculates the Relative Strength Index (RSI) for a group of stocks  args:  ------    rsi_n: (list) size of rsi look-back period    stocks_n: (int) number of stocks to retrieve the rsi for    file_path (str): path leading to csv file of S&amp;P500 component              stocks    ind_excld: (list) GICS Sector industries to be excluded  Return:  ------    df_rsi: (pd. DataFrame) returns the rsi reading for the list of         stocks and whether the 30/70 level has been breached  &quot;&quot;&quot;  sp500_stocks_df = get_sp500_stocks_file(file_path=file_path)  sp500_stocks_df_excld = filter_stocks_industry(sp500_stocks_df,                          ind_excld=ind_excld)    sp500_stocks_df_excld = sp500_stocks_df_excld. head(stocks_n)  info, symbols = get_stock_price(sp500_stocks_df_excld)  sp500_stocks_price_df = get_stock_price_df(info, symbols)  symbols = sp500_stocks_price_df[&#39;Symbol&#39;]. unique()  rsi_l = []  status_l = []  for s in symbols:    s_df = sp500_stocks_price_df[sp500_stocks_price_df[&#39;Symbol&#39;] == s]    closep = np. array(s_df[&#39;Close&#39;]. tolist())    closep = closep. astype(np. float)    rsi = get_rsi(closep, n=rsi_n)    if rsi[-1] &gt;=70:      status = &#39;Above 70&#39;    elif rsi[-1] &lt;= 30:      status = &#39;Below 30&#39;    else:      status = &#39;Normal&#39;    rsi_l. append(round(rsi[-1], 1))    status_l. append(status)  df_rsi = pd. DataFrame(zip(symbols, rsi_l, status_l),             columns=[&#39;Symbols&#39;, &#39;RSI&#39;, &#39;Status&#39;])  return df_rsi    For this example, there is only one stock (AMD) that crossed the 30/70 threshold.       df_rsi = get_stocks_rsi(rsi_n=14, stocks_n=10,             file_path=&#39;. /data/sp500_stocks. csv&#39;,             ind_excld=[&#39;Health Care&#39;, &#39;Utilities&#39;, &#39;Energy&#39;])df_rsi. head(10)           Symbols   RSI   Status         0   MMM   49. 6   Normal       1   ACN   53. 1   Normal       2   ATVI   66. 0   Normal       3   ADBE   39. 4   Normal       4   AMD   29. 1   Below 30       5   AAP   44. 5   Normal       6   AFL   35. 0   Normal       7   APD   42. 2   Normal       8   AKAM   67. 4   Normal       9   ALK   42. 9   Normal     Let's breakdown get_stocks_rsi. First we retrieve a dataframe of the S&amp;P500 component stocks. Thankfully we have already saved it in a csv file earlier and all we need to do is to read the file.       def get_sp500_stocks_file(file_path=None):  &quot;&quot;&quot;  Reads a csv file containing the wikipedia S&amp;P500 component stocks table  args:  ------    file_path: (str) path leading to the csv file  Return:  ------    df: (pd. DataFrame) a copy of the wikipedia table  &quot;&quot;&quot;  df = pd. read_csv(file_path)  return df          sp500_stocks_df = get_sp500_stocks_file(file_path=&quot;. /data/sp500_stocks. csv&quot;)sp500_stocks_df[[&#39;Ticker&#39;, &#39;Security&#39;, &#39;GICS&#39; ]]. head(10)           Ticker   Security   GICS         0   MMM   3M Company   Industrials       1   ABT   Abbott Laboratories   Health Care       2   ABBV   AbbVie Inc.    Health Care       3   ABMD   ABIOMED Inc   Health Care       4   ACN   Accenture plc   Information Technology       5   ATVI   Activision Blizzard   Communication Services       6   ADBE   Adobe Inc.    Information Technology       7   AMD   Advanced Micro Devices Inc   Information Technology       8   AAP   Advance Auto Parts   Consumer Discretionary       9   AES   AES Corp   Utilities     You can exclude any industries that you are not interested in. In this scenario, I have excluded companies from the Health Care, Utilities and Energy industries.       def filter_stocks_industry(df, ind_excld=[]):  &quot;&quot;&quot;  Filters a dataframe based on the GICS industries  args:  ------    df: (pd. DataFrame) a copy of the wikipedia table    ind_excld: (list) GICS industries to be excluded  Return:  ------    df_excld: (pd. DataFrame) filtered dataframe  &quot;&quot;&quot;  df_excld = df[~df[&#39;GICS&#39;]. isin(ind_excld)]  return df_excld          sp500_stocks_df_excld = filter_stocks_industry(sp500_stocks_df,                        ind_excld=[&#39;Health Care&#39;,                             &#39;Utilities&#39;,                             &#39;Energy&#39;])sp500_stocks_df_excld[[&#39;Ticker&#39;, &#39;Security&#39;, &#39;GICS&#39; ]]. head(10)           Ticker   Security   GICS         0   MMM   3M Company   Industrials       4   ACN   Accenture plc   Information Technology       5   ATVI   Activision Blizzard   Communication Services       6   ADBE   Adobe Inc.    Information Technology       7   AMD   Advanced Micro Devices Inc   Information Technology       8   AAP   Advance Auto Parts   Consumer Discretionary       10   AFL   AFLAC Inc   Financials       12   APD   Air Products &amp; Chemicals Inc   Materials       13   AKAM   Akamai Technologies Inc   Information Technology       14   ALK   Alaska Air Group Inc   Industrials     Now that we have the stocks that we would like to focus on, it is time for us to get the historical stock price for each of them. We will use the first 10 stocks of our dataframe for illustration. As Alpha Vantage limits the number of API calls per minute (5 calls/minute), we will tell the program to retrieve the stock information at intervals of 65 seconds.       def get_stock_price(df_excld):  &quot;&quot;&quot;  Retrieves the daily stock price from a dataframe of stocks and their  respective tickers  args:  ------    df_excld: (pd. DataFrame) filtered dataframe of stocks containing only         stocks from selected industries  Return:  ------    info: (list) a complete history of stocks&#39; pricing/volume information     symbols: (list) stock tickers  &quot;&quot;&quot;  ts = TimeSeries(ALPHA_VANTAGE_KEY)  info = []  symbols = []  counter = 0  for t in df_excld[&#39;Ticker&#39;]:    if counter % 5 == 0:      time. sleep(65)    i, m = ts. get_daily(symbol=t, outputsize=&#39;full&#39;)    info. append(i)    symbols. append(m[&#39;2. Symbol&#39;])    counter += 1  return info, symbols          sp500_stocks_df_excld = sp500_stocks_df_excld. head(10)info, symbols = get_stock_price(sp500_stocks_df_excld)    We have managed to obtain the price and volume information for our stocks. Let's zoom in and look at MMM's (first ticker) pricing and volume information.       info[0][&#39;2020-02-28&#39;]  {&#39;1. open&#39;: &#39;154. 0900&#39;, &#39;2. high&#39;: &#39;156. 7200&#39;, &#39;3. low&#39;: &#39;146. 0000&#39;, &#39;4. close&#39;: &#39;149. 2400&#39;, &#39;5. volume&#39;: &#39;11498521&#39;}  And these are the stocks that we have extracted the information for.       symbols  [&#39;MMM&#39;, &#39;ACN&#39;, &#39;ATVI&#39;, &#39;ADBE&#39;, &#39;AMD&#39;, &#39;AAP&#39;, &#39;AFL&#39;, &#39;APD&#39;, &#39;AKAM&#39;, &#39;ALK&#39;]  Now that we have retrieved all the information we need, let's convert it into a dataframe for better visualization.       def get_stock_price_df(info, symbols):  &quot;&quot;&quot;  Converts pricing/volume information and the stocks symbols into  a dataframe  args:  ------    info: (list) a complete history of stocks&#39; pricing/volume information     symbols: (list) stock tickers  Return:  ------    df_full: (pd. DataFrame) consists of stock tickers their pricing/volume         information  &quot;&quot;&quot;  df_l = []  for num, i in enumerate(info):    df = pd. DataFrame. from_dict(i, orient=&#39;index&#39;)    df[&#39;Symbol&#39;] = symbols[num]    df_l. append(df)  df_full = pd. concat(df_l)  df_full = df_full. rename(columns={&#39;1. open&#39;: &#39;Open&#39;,                   &#39;2. high&#39;: &#39;High&#39;,                   &#39;3. low&#39;: &#39;Low&#39;,                   &#39;4. close&#39;: &#39;Close&#39;,                   &#39;5. volume&#39;: &#39;Volume&#39;})  return df_full          sp500_stocks_price_df = get_stock_price_df(info, symbols)sp500_stocks_price_df. head(5)           Open   High   Low   Close   Volume   Symbol         2020-03-03   152. 4400   154. 0000   144. 4400   145. 2400   8253737   MMM       2020-03-02   151. 3400   153. 4300   148. 3700   153. 0200   8021045   MMM       2020-02-28   154. 0900   156. 7200   146. 0000   149. 2400   11498521   MMM       2020-02-27   151. 2300   155. 4300   149. 0000   150. 1600   8217960   MMM       2020-02-26   149. 5700   151. 8200   148. 0900   148. 9600   5151670   MMM     Finally, we can feed the stock prices into get_rsi to obtain the RSI readings.       def get_rsi(prices, n=14):  &quot;&quot;&quot;  Calculates the Relative Strength Index (RSI) for a stock  Credits: sentdex - https://www. youtube. com/watch?v=4gGztYfp3ck  args:  ------    prices: (list) prices for a stock    n: (int) size of RSI look-back period  Return:  ------    rsi: (float): momentum indicator that measures the magnitude of recent           price changes to evaluate overbought or oversold            conditions    https://www. investopedia. com/terms/r/rsi. asp  &quot;&quot;&quot;  deltas = np. diff(prices)  seed = deltas[:n+1]  up = seed[seed &gt;= 0]. sum()/n  down = -seed[seed &lt; 0]. sum()/n  rs = up/down  rsi = np. zeros_like(prices)  rsi[:n] = 100. - 100. /(1. + rs)  for i in range(n, len(prices)):    delta = deltas[i-1]    if delta &gt; 0:      upval = delta      downval = 0.     else:      upval = 0.       downval = -delta    up = (up*(n-1) + upval)/n    down = (down*(n-1) + downval)/n    rs = up/down    rsi[i] = 100. - 100. /(1. +rs)  return rsi    Converting our RSI readings from a dataframe to concatenated strings&#182;: Unfortunately, as much as we want to, we are not able to send the whole dataframe we have created above as a message to our Slack channel. One workaround is for us to first extract the stock tickers and RSI readings as strings. After that, we will concatenate the strings together before sending them to our Slack channel.        def get_rsi_string(df_rsi, head_n=20, tail_n=20):  &quot;&quot;&quot;  Converts the RSI readings into strings to be displayed in Slack  args:  ------    df_rsi: (pd. DataFrame) the rsi readings for a list of         stocks and whether the 30/70 levels have been breached    head_n: (int) number of top ranked stocks (based on rsi) reading        to be displayed in Slack    tail_n: (int) number of bottom ranked stocks (based on rsi) reading         to be displayed in Slack  Return:  ------    top_str: (str) concatenated string for top ranked stocks&#39; rsi         reading    btm_str: (str) concatenated string for bottom ranked stocks&#39; rsi         reading  &quot;&quot;&quot;  df_rsi = df_rsi. sort_values(&#39;RSI&#39;, ascending=False)  df_top = df_rsi. head(head_n)  df_btm = df_rsi. tail(tail_n)  top_symbols = df_top[&#39;Symbols&#39;]. tolist()  btm_symbols = df_btm[&#39;Symbols&#39;]. tolist()  top_rsi = df_top[&#39;RSI&#39;]. tolist()  btm_rsi = df_btm[&#39;RSI&#39;]. tolist()  top_l = list(zip(top_symbols, top_rsi))  btm_l = list(zip(btm_symbols, btm_rsi))  top_str = &quot;&quot;  for el in top_l:    top_str = top_str + str(el[0]) + &quot; &quot; + str(el[1]) + &quot;\n&quot;  btm_str = &quot;&quot;  for el in btm_l:    btm_str = btm_str + str(el[0]) + &quot; &quot; + str(el[1]) + &quot;\n&quot;  return top_str, btm_str          top_str, btm_str = get_rsi_string(df_rsi, head_n=5, tail_n=5)    This is the concatenated string for the top 5/ bottom 5 ranked stocks (based on RSI readings). The escape sequence  \n  will help to display each stock on a new line when viewed on the Slack channel.       top_str  &#39;AKAM 67. 4\nATVI 66. 0\nACN 53. 1\nMMM 49. 6\nAAP 44. 5\n&#39;        btm_str  &#39;ALK 42. 9\nAPD 42. 2\nADBE 39. 4\nAFL 35. 0\nAMD 29. 1\n&#39;  We're almost there! Let's integrate our code with Slack's API&#182;: For us to send the concatenated string to our Slack Channel, Slack requires us to format our strings in the form of a  block  that contains other required meta information. We will be using the _get_text_block helper function to help us do just that.       def _get_text_block(self, string):  &quot;&quot;&quot;  Helper function for get_message_payload_stock.   Used to convert a string into a slack formatted text block.   args:  ------    string: (str) concatenated string for the top or bottom ranked         stocks&#39; rsi reading  Return:  ------    dictionary containing the correctly formatted text block to be    displayed in slack  &quot;&quot;&quot;  return {&quot;type&quot;: &quot;section&quot;, &quot;text&quot;: {&quot;type&quot;: &quot;mrkdwn&quot;, &quot;text&quot;: string}}    We can then piece together our  text_block  with other user specific information to create our payload. Additional information that are required: channel: ID of the channel that we are sending this message tousername: The name of our slackbotWe will use the following two methods to send two types of payload: get_message_payload_stock: used to send our RSI readings to the Slack channel. This payload includes a divider block that separates the top and bottom ranked RSI readings. get_message_paylaod: used to send simple texts.       def get_message_payload_stock(self, top_str, btm_str):  &quot;&quot;&quot;  Used to create a message payload to send stock rsi readings  args:  ------    top_str: (str) concatenated string for the top ranked stocks&#39;         rsi readings    bottom_str: (str) concatenated string for the bottom ranked stocks&#39;          rsi readings  Return:  ------    dictionary containing payload (stock rsi readings) to be sent using    Slack&#39;s API  &quot;&quot;&quot;  return {    &quot;channel&quot;: self. channel,    &quot;username&quot;: self. username,    &quot;blocks&quot;: [      self. _get_text_block(top_str),      self. DIVIDER_BLOCK,      self. _get_text_block(btm_str)    ],  }          def get_message_payload(self, string):  &quot;&quot;&quot;  Used to create a message payload to send simple text messages  args:  ------    string: (str) string to be sent using Slack&#39;s API  Return:  ------    dictionary containing payload (simple text messages) to be sent    using Slack&#39;s API  &quot;&quot;&quot;  return {    &quot;channel&quot;: self. channel,    &quot;username&quot;: self. username,    &quot;text&quot;: string  }    Wait a minute. . . &#182;: Before I demonstrate how we can use the methods to send our payloads to Slack, I would like to introduce get_fed_holidays which will help us retrieve the days that the US market is closed. When the market is closed, we are not able to retrieve new stock information, hence there is no need for us to retrieve new RSI readings. During periods like this, we can give our bot a break and instead notify us with a message 'Market closed, US Federal holiday'.       def get_fed_holidays(start_date, end_date):  &quot;&quot;&quot;  Retrieve a dataframe outlining the days that the US market is closed  args:  ------    start_date: (str) start date for the period in focus    end_date: (str) end date for the period in focus  Return:  ------    df_holiday: (pd. DataFrame) returns the days that are US market holidays  &quot;&quot;&quot;  dr = pd. date_range(start=start_date, end=end_date)  df = pd. DataFrame()  df[&#39;Date&#39;] = dr  cal = calendar()  holidays = cal. holidays(start=dr. min(), end=dr. max())  df[&#39;Holiday&#39;] = df[&#39;Date&#39;]. isin(holidays)  df_holiday = df[df[&#39;Holiday&#39;] == True]  return df_holiday    Ok now let us see how we can send simple text messages and our RSI readings sent to Slack. Let's first instantiate the class with our channel ID       s = Smartie(CHANNEL_ID)    If it is a US Federal holiday, the following payload will be sent to the Slack channel. . . .       message = s. get_message_payload(&#39;Market closed, US Federal holiday&#39;)message  {&#39;channel&#39;: &#39;CU560GVCG&#39;, &#39;text&#39;: &#39;Market closed, US Federal holiday&#39;, &#39;username&#39;: &#39;smartie&#39;}  . . . else we will send the RSI readings.       message = s. get_message_payload_stock(top_str, btm_str)message  {&#39;blocks&#39;: [{&#39;text&#39;: {&#39;text&#39;: &#39;AKAM 67. 4\nATVI 66. 0\nACN 53. 1\nMMM 49. 6\nAAP 44. 5\n&#39;,  &#39;type&#39;: &#39;mrkdwn&#39;},  &#39;type&#39;: &#39;section&#39;}, {&#39;type&#39;: &#39;divider&#39;}, {&#39;text&#39;: {&#39;text&#39;: &#39;ALK 42. 9\nAPD 42. 2\nADBE 39. 4\nAFL 35. 0\nAMD 29. 1\n&#39;,  &#39;type&#39;: &#39;mrkdwn&#39;},  &#39;type&#39;: &#39;section&#39;}], &#39;channel&#39;: &#39;CU560GVCG&#39;, &#39;username&#39;: &#39;smartie&#39;}  Sending our first message!&#182;Let's put everything we have worked on so far and see how the messages looks like on our Slack channel!       import slackslack_web_client = slack. WebClient(token=SLACK_BOT_TOKEN)          response = slack_web_client. chat_postMessage(**message)response  &lt;slack. web. slack_response. SlackResponse at 0x7f70e6eb45c0&gt;        import logginglogger = logging. getLogger()logger. setLevel(logging. DEBUG)s = Smartie(CHANNEL_ID)logger. info(&#39;Getting fed holidays&#39;)range_start_date = &#39;2020-01-01&#39;range_end_date = &#39;2020-12-31&#39;fed_holiday = get_fed_holidays(start_date=range_start_date,                end_date=range_end_date)if str(datetime. datetime. now(). date()) in fed_holiday:  logger. info(&#39;It is a Holiday&#39;)  message = s. get_message_payload(&#39;Market closed, US Federal holiday&#39;)else:  logger. info(&#39;It is not a Holiday&#39;)  df_rsi = s. get_stocks_rsi(rsi_n=14, stocks_n=10)  top_str, btm_str = s. get_rsi_string(df_rsi, head_n=5, tail_n=5)  message = s. get_message_payload_stock(top_str, btm_str)logger. info(&#39;Posting on Slack&#39;)response = slack_web_client. chat_postMessage(**message)    Great! You should have received a message like the one below in your channel (that is if isn't a US Federal holiday).  Deployment&#182;Dockerfile&#182;: The Dockerfile outlines a set of instructions/commands needed to build a docker image. This can include simple commands such as COPY which adds files from a source on your computer into the Docker image. We will use the Miniconda base image which comes with Python.       # our base imageFROM continuumio/miniconda3# update essential packagesRUN apt update &amp;&amp; \  apt -y install bzip2 curl gcc ssh rsync git vim cron &amp;&amp; \  apt-get clean# creating our conda environmentARG CONDA_ENV_FILEARG CONDA_PATH=&quot;/root/miniconda3/bin&quot;ARG CONDA_BIN=&quot;$CONDA_PATH/conda&quot;COPY $CONDA_ENV_FILE $CONDA_ENV_FILEENV SHELL /bin/bashRUN conda install nb_condaENV PATH /root/miniconda3/envs/stock_screener/bin:$CONDA_PATH:$PATH# update the environmentCOPY conda. yml . RUN conda env update -n stock_screener --file . /conda. yml# adding our environment variables for Cron job to workRUN printenv &gt;&gt; /etc/environment# allow log messages to be printed in interactive terminalENV PYTHONUNBUFFERED 1# run shell scriptRUN chmod +x . /run. shENTRYPOINT [&quot;. /run. sh&quot;]    Conda. yml&#182;: The conda. yml file will be used to upgrade the python version and install any package dependencies that we need in our conda environment.       channels: - defaultsdependencies: - python=3. 6. 7 - pip=19. 0. 3 - nb_conda - pip:  - alpha-vantage==2. 1. 3  - beautifulsoup4==4. 8. 2  - pandas==1. 0. 1  - numpy==1. 18. 1  - slack==0. 0. 2  - slackclient==2. 5. 0  - slackeventsapi==2. 1. 0  - websocket-client==0. 57. 0    run. sh&#182;: For our log messages to be printed out in the interactive terminal, we will need to create a softlink /var/log/cron. log to /proc/1/fd/1. This will allow standard output and error streams that are passed to the softlink /var/log/cron. log to be directed to /proc/1/fd/1 which can then be viewed in the interactive terminal. As we would like the app to send us updates on a periodic basis, we will have to tell the server to run our code repeatedly. To do this, we can use the Cron service which is available on our server by listing down the things we need the Cron service to work on in the /etc/crontab file. * denotes the schedule that the code will run at. As an example, 0 1 * * * will mean that the code will run every day at 1am. Currently, I have scheduled the script to run every 5 minutes for testing */5 * * * *.        #!/bin/bashprintenv &gt; /etc/default/localeservice cron startecho &#39;Smartie is ready for action!&#39;ln -sf /proc/1/fd/1 /var/log/cron. logecho &#39;*/5 * * * * root cd / &amp;&amp; /opt/conda/envs/stock_screener/bin/python . /app. py &gt;&gt; /var/log/cron. log&#39; &gt; /etc/crontabtail -f /var/log/cron. log    env. list (you will need to create this)&#182;: Remember the credentials that we painstakingly created and saved in credentials. py? You will need to create a env. list file and copy all your credentials over. Just that this time, the double quotes    can be omitted from the env. list file. Save the file on your local computer. You should have something similar in env. list.       SLACK_API_TOKEN=xoxp-945736515923-959414305302. . . . CHANNEL_ID=CU. . . SLACK_BOT_TOKEN=xoxb-945736515923-957048941172. . . . . SLACK_SIGNING_SECRET=88a3424d. . . . . ALPHA_VANTAGE_KEY=E1UR. . . .     Creating the docker image on docker hub&#182;: First let's build the Docker image from the Dockerfile. You will need to run the following code in your terminal, in the same directory as the Dockerfile. Replace  kennethwang92  with your Docker ID. docker build -t kennethwang92/stock_screener After building, you can tag it with a name eg. demo and push the image to docker hub. Replace 0e5574283393 with your image ID. By default your image would have been tagged with  latest , you can substitute it with another label if you prefer. In this example, let's label the image as demo. docker tag 0e5574283393 kennethwang92/stock_screener:demo Login to docker hub on your terminal. Key in your username and password when prompted. docker login docker. io Push the image to docker hub. docker push kennethwang92/stock_screener:demo Deploying on a Digital Ocean server (droplet)&#182;Now that we have pushed the image to Docker hub, we can create a server using Digital Ocean for us to deploy the container. Below is a step-by-step guide on how to create a server (Digital Ocean calls it a droplet). Creating a server&#182;: Set up an account with Digital Ocean here.  Create a project.  Create a droplet.  Select ubuntu.  Choose a plan.  Select a datacenter.  Create ssh. Click on  New SSH Key  and follow the instructions.  Click on create droplet.  Select droplet.  Save the IP address. We will need to use it in the next section.  Connecting to the server and building the docker container&#182;: First let's copy the env. list file that you saved in your local computer into the server. You will have to amend ~/. ssh/id_rsa and . /env. list depending on where you have saved your ssh keys and env. list file. Insert the [ip address] that you have saved in the earlier section. scp -r -i ~/. ssh/id_rsa . /env. list root@[ip address]:~ Now we will connect to the server. ssh -i ~/. ssh/id_rsa root@[ip address] You should see on your terminal that you have connected to the server.  While in the server, type the following commands in the following order to: Update apt-get command-line tool for handling packagesapt-get update Install dockerapt install docker. io Download the image from Docker Hubdocker pull kennethwang92/stock_screener: demo Run the image with our credentials in env. list to create our docker container. Replace . /env. list with the path leading to your env. list file. For my case I have saved the file on my desktop. Replace  kennethwang92  with your Docker ID if you would like to use your own image. Ensure that you are running this code in the same directory as the env. list file. docker run -it --env-file . /env. list kennethwang92/stock_screener: demo /bin/bash And we're done! Check your Slack channel for the messages! Future improvements:&#182;Slack bots are really powerful and when used with python, the possibilities are endless. Here are some improvements I can think of: Instead of using RSI, you can use other indicators that you are interested in. You can even execute trades through the bot if your broker has an API that you can connect to. Send . png/. jpg graphs instead of texts.  I hope you enjoyed this article and you find the Slack bot useful. If you have any questions/comments please feel free to reach out to me through Linkedin or email at ken. wangtm@gmail. com "
    }];

var idx = lunr(function () {
    this.ref('id')
    this.field('title')
    this.field('body')
    this.metadataWhitelist = ['position']

    documents.forEach(function (doc) {
        this.add(doc)
    }, this)
});
function lunr_search(term) {
    document.getElementById('lunrsearchresults').innerHTML = '<ul></ul>';
    if(term) {
        document.getElementById('lunrsearchresults').innerHTML = "<p>Search results for '" + term + "'</p>" + document.getElementById('lunrsearchresults').innerHTML;
        //put results on the screen.
        var results = idx.search(term);
        if(results.length>0){
            //console.log(idx.search(term));
            //if results
            for (var i = 0; i < results.length; i++) {
                // more statements
                var ref = results[i]['ref'];
                var url = documents[ref]['url'];
                var title = documents[ref]['title'];
                var body = documents[ref]['body'].substring(0,160)+'...';
                document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML + "<li class='lunrsearchresult'><a href='" + url + "'><span class='title'>" + title + "</span><br /><span class='body'>"+ body +"</span><br /><span class='url'>"+ url +"</span></a></li>";
            }
        } else {
            document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = "<li class='lunrsearchresult'>No results found...</li>";
        }
    }
    return false;
}