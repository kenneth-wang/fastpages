
var documents = [{
    "id": 0,
    "url": "https://kenneth-wang.github.io/404.html",
    "title": "",
    "body": " 404 Page not found :(  The requested page could not be found. "
    }, {
    "id": 1,
    "url": "https://kenneth-wang.github.io/about/",
    "title": "About Me",
    "body": "This is where you put the contents of your About page. Like all your pages, it’s in Markdown format. This website is powered by fastpages 1.       a blogging platform that natively supports Jupyter notebooks in addition to other formats.  &#8617;    "
    }, {
    "id": 2,
    "url": "https://kenneth-wang.github.io/categories/",
    "title": "Tags",
    "body": "Contents: {% if site. categories. size &gt; 0 %} {% for category in site. categories %} {% capture category_name %}{{ category | first }}{% endcapture %} {{ category_name }}{% endfor %}{% endif %} {% for category in site. categories %}  {% capture category_name %}{{ category | first }}{% endcapture %} &lt;h3 id = {{ category_name }} &gt;&lt;i class= fas fa-tags category-tags-icon &gt;&lt;/i&gt;&lt;/i&gt; {{ category_name }}&lt;/h3&gt;&lt;a name= {{ category_name | slugize }} &gt;&lt;/a&gt;{% for post in site. categories[category_name] %}{%- assign date_format = site. minima. date_format | default:  %b %-d, %Y  -%}&lt;article class= archive-item &gt; &lt;p class= post-meta post-meta-title &gt;&lt;a class= page-meta  href= {{ site. baseurl }}{{ post. url }} &gt;{{post. title}}&lt;/a&gt; • {{ post. date | date: date_format }}&lt;/p&gt;&lt;/article&gt;{% endfor %} {% endfor %}"
    }, {
    "id": 3,
    "url": "https://kenneth-wang.github.io/images/copied_from_nb/",
    "title": "",
    "body": "WarningDo not manually save images into this folder. This is used by GitHub Actions to automatically copy images.  Any images you save into this folder could be deleted at build time. "
    }, {
    "id": 4,
    "url": "https://kenneth-wang.github.io/2020/03/03/_03_01_Smartie_Slackbot.html",
    "title": "Smartie",
    "body": "2020/03/03 -           There is an abundance of websites/news app that are offering watchlists for you to get timely information on stocks. However it may be difficult for us to find one that is customizable and able to give us more than just price movements. By the end of this post, I hope you can create your own Slack bot that gives you personalized information based on your needs. Through this article, we will be working through the steps together to create a bot that sends you a set of S&amp;P500 stocks and their Relative Strength Index (RSI) on a periodic basis. You can always amend the code to send yourself other stock information that you are interested in. In terms of deployment, the app with all of its dependencies will be packaged into a docker image and be pushed to Docker Hub, a service provided by Docker to share container images. With the docker image, we will build a docker container that includes everything we need to run the app on a server. For this example, I will be using Digital Ocean to host the app. Ok let's get started! Project directory structure&#182;The files that we will be referring to can be found here and in this section, I will illustrate how the different files will fit together. Before delving into the code and to avoid any confusion, let's look at how the files are arranged. The sp500_stocks. csv file contains the current constituents of the popular SP500 stock index. The classes/functions that we will be building can be found in the stock. py and app. py files.  The rest of the files will be used to build the docker image/container for us to deploy on the server.       smartie/_______ data/___________ sp500_stocks. csv_______ src/___________ __init__. py___________ stock. py_______ app. py_______ conda. yml_______ Dockerfile_______ credentials. py # To be created by user_______ env. list # To be created by user_______ run. sh    Generating the credentials we need&#182;Before we are able to send any stock related information to a Slack channel, we will need to retrieve some credentials/IDs from Alpha Vantage and Slack. We will store them in a credentials. py file to be used with this notebook. Click on the links below to setup the credentials. ALPHA_VANTAGE_KEY: We will be using Alpha Vantage to retrieve the stock prices. Ever since Yahoo decided to discontinue their finance API service,it has been difficult for many users to find a new platform to access pricing data for free. Alpha Vantage offers the data for free, however if you are looking to create a high-frequency trading bot, you will probably find yourself disappointed. There is a limit of 5 API-requests per minute and 500 API requests per day. But you can always subscribe to their paid services if you are looking to remove these limits. API token: This is required to use Slack's API service for your selected Development Slack Workspace (channel). Follow the instructions in the link to obtain an access key. Channel ID: This is required to access the channel you have attached your app to. Slack Bot Token: Credentials required to use the bot associated with your channel Slack Signing Secret: A unique string that Slack shares with us. When sending a request, the signing secret is combined with the body using a HMAC-SHA256 keyed hash. The resulting signature is unique and is used by Slack to verify that the request is actually sent by you. This can be found under  Basic Information  on the side bar of the Slack API webpage       # You should have something similar in credential. pySLACK_API_TOKEN=&quot;xoxp-945736515923-959414305302. . . . &quot;CHANNEL_ID=&quot;CU. . . &quot;SLACK_BOT_TOKEN=&quot;xoxb-945736515923-957048941172. . . . . &quot;SLACK_SIGNING_SECRET=&quot;88a3424d. . . . . &quot;ALPHA_VANTAGE_KEY=&quot;E1UR. . . . &quot;    If you are running the notebook using Google Colab, remember to mount the directory that you are working from.       %%capturefrom google. colab import drivedrive. mount(&#39;/content/gdrive/&#39;)%cd /content/gdrive/My Drive/Colab Notebooks/ssh_files/smartie_slackbotimport syssys. path. append(&quot;. &quot;)  Go to this URL in a browser: https://accounts. google. com/o/oauth2/auth?client_id=947318989803-6bn6qk8qdgf4n4g3pfee6491hc0brc4i. apps. googleusercontent. com&amp;redirect_uri=urn%3aietf%3awg%3aoauth%3a2. 0%3aoob&amp;response_type=code&amp;scope=email%20https%3a%2f%2fwww. googleapis. com%2fauth%2fdocs. test%20https%3a%2f%2fwww. googleapis. com%2fauth%2fdrive%20https%3a%2f%2fwww. googleapis. com%2fauth%2fdrive. photos. readonly%20https%3a%2f%2fwww. googleapis. com%2fauth%2fpeopleapi. readonlyEnter your authorization code:··········        from credentials import SLACK_API_TOKEN, CHANNEL_ID, SLACK_BOT_TOKEN, \            SLACK_SIGNING_SECRET, ALPHA_VANTAGE_KEY    Requirements&#182;Not to forget, we need to installing the dependencies. . .       %%capture!pip install alpha-vantage==2. 1. 3!pip install beautiful soup4==4. 8. 2!pip install slack==0. 0. 2!pip install slackclient==2. 5. 0!pip install slackeventsapi==2. 1. 0!pip install websocket-client==0. 57. 0    . . . and import the python packages that we will be using       import requestsimport timeimport pandas as pdimport numpy as npimport slackimport ssl as ssl_libimport certifiimport datetimefrom bs4 import BeautifulSoupfrom alpha_vantage. timeseries import TimeSeriesfrom pandas. tseries. holiday import USFederalHolidayCalendar as calendarfrom flask import Flaskfrom slackeventsapi import SlackEventAdapter    Retrieving the S&amp;P500 component stocks from wikipedia&#182;To get a list of S&amp;P500 component stocks, we will scrape a table from a wikipedia webpage. As and when you require an updated list, you can revisit this function.       def get_sp500_stocks_wiki(url=None):  &quot;&quot;&quot;  Scapes a wikipedia web page to retrieve a table of S&amp;P500 component stocks.   Use this function if you require an updated table.   args:  ------    url: (str) url leading to the wikipedia web page  Return:  ------    df: (pd. DataFrame) a copy of the wikipedia table   &quot;&quot;&quot;  website_url = requests. get(url)  soup = BeautifulSoup(website_url. text, &#39;lxml&#39;)  my_table = soup. find(&#39;table&#39;, {&#39;class&#39;: &#39;wikitable sortable&#39;})  my_table  table_rows = my_table. find_all(&#39;tr&#39;)  data = []  for row in table_rows:    data. append([t. text. strip() for t in row. find_all(&#39;td&#39;)])  df = pd. DataFrame(data[1:], columns=[&#39;Ticker&#39;, &#39;Security&#39;, &#39;SEC_Filings&#39;,                     &#39;GICS&#39;, &#39;GICS_Sub&#39;, &#39;HQ&#39;,                     &#39;Date_First_Added&#39;, &#39;CIK&#39;, &#39;Founded&#39;])  return df    Although we have scrapped the whole table, we are mainly interested in the tickers, security name and GICS classification.       sp500_stocks_df = get_sp500_stocks_wiki(&quot;https://en. wikipedia. org/wiki/List_of_S%26P_500_companies&quot;)sp500_stocks_df. to_csv(&#39;. /data/sp500_stocks. csv&#39;, index=False)sp500_stocks_df[[&#39;Ticker&#39;, &#39;Security&#39;, &#39;GICS&#39; ]]. head(5)           Ticker   Security   GICS         0   MMM   3M Company   Industrials       1   ABT   Abbott Laboratories   Health Care       2   ABBV   AbbVie Inc.    Health Care       3   ABMD   ABIOMED Inc   Health Care       4   ACN   Accenture plc   Information Technology     Let's start coding our Slack bot!&#182;I have named my Slack bot as Smartie, and I have a created a class with a similar name. The class serves three main purposes: To retrieve the RSI of the stocks that we are interested in get_stocks_rsi. To convert the RSI readings into strings that can be read as texts on the Slack app get_rsi_string. To package the strings above in Slack compatible blocks and send them to our Slack channel with the relevant meta information get_message_payload_stock, get_message_payload. Fret not, if the class looks overwhelming! We will go through each of the methods so that you are able amend this class for your own use case.       class Smartie:  &quot;&quot;&quot;Slack app that sends stock analysis results for the day. &quot;&quot;&quot;  def __init__(self, channel):    self. channel = channel    self. username = &quot;smartie&quot;    self. reaction_task_completed = False    self. pin_task_completed = False    self. DIVIDER_BLOCK = {&quot;type&quot;: &quot;divider&quot;}  def get_stocks_rsi(self, rsi_n=14, stocks_n=100,            file_path=&#39;. /data/sp500_stocks. csv&#39;,            ind_excld=[&#39;Health Care&#39;, &#39;Utilities&#39;, &#39;Energy&#39;]):    &quot;&quot;&quot;    Calculates the Relative Strength Index (RSI) for a group of stocks    args:    ------      rsi_n: (list) size of rsi look-back period      stocks_n: (int) number of stocks to retrieve the rsi for      file_path (str): path leading to csv file of S&amp;P500 component                stocks      ind_excld: (list) GICS Sector industries to be excluded    Return:    ------      df_rsi: (pd. DataFrame) returns the rsi reading for the list of           stocks and whether the 30/70 levels have been breached    &quot;&quot;&quot;    sp500_stocks_df = get_sp500_stocks_file(file_path=file_path)    sp500_stocks_df_excld = filter_stocks_industry(sp500_stocks_df,                            ind_excld=ind_excld)    sp500_stocks_df_excld = sp500_stocks_df_excld. head(stocks_n)    info, symbols = get_stock_price(sp500_stocks_df_excld)    sp500_stocks_price_df = get_stock_price_df(info, symbols)    symbols = sp500_stocks_price_df[&#39;Symbol&#39;]. unique()    rsi_l = []    status_l = []    for s in symbols:      s_df = sp500_stocks_price_df[sp500_stocks_price_df[&#39;Symbol&#39;] == s]      closep = np. array(s_df[&#39;Close&#39;]. tolist())      closep = closep. astype(np. float)      rsi = get_rsi(closep, n=rsi_n)      if rsi[-1] &gt;=70:        status = &#39;Above 70&#39;      elif rsi[-1] &lt;= 30:        status = &#39;Below 30&#39;      else:        status = &#39;Normal&#39;      rsi_l. append(round(rsi[-1], 1))      status_l. append(status)    df_rsi = pd. DataFrame(zip(symbols, rsi_l, status_l),               columns=[&#39;Symbols&#39;, &#39;RSI&#39;, &#39;Status&#39;])    return df_rsi  def get_rsi_string(self, df_rsi, head_n=20, tail_n=20):    &quot;&quot;&quot;    Converts the RSI readings into strings to be displayed in Slack    args:    ------      df_rsi: (pd. DataFrame) the rsi readings for a list of           stocks and whether the 30/70 levels have been breached      head_n: (int) number of top ranked stocks (based on rsi) reading          to be displayed in Slack      tail_n: (int) number of bottom ranked stocks (based on rsi) reading           to be displayed in Slack    Return:    ------      top_str: (str) concatenated string for top ranked stocks&#39; rsi           reading      btm_str: (str) concatenated string for bottom ranked stocks&#39; rsi           reading    &quot;&quot;&quot;    df_rsi = df_rsi. sort_values(&#39;RSI&#39;,ascending=False)    df_top = df_rsi. head(head_n)    df_btm = df_rsi. tail(tail_n)    top_symbols = df_top[&#39;Symbols&#39;]. tolist()    btm_symbols = df_btm[&#39;Symbols&#39;]. tolist()    top_rsi = df_top[&#39;RSI&#39;]. tolist()    btm_rsi = df_btm[&#39;RSI&#39;]. tolist()    top_l = list(zip(top_symbols, top_rsi))    btm_l = list(zip(btm_symbols, btm_rsi))    top_str = &quot;&quot;    for el in top_l:      top_str = top_str + str(el[0]) + &quot; &quot; + str(el[1]) + &quot;\n&quot;    btm_str = &quot;&quot;    for el in btm_l:      btm_str = btm_str + str(el[0]) + &quot; &quot; + str(el[1]) + &quot;\n&quot;    return top_str, btm_str  def _get_text_block(self, string):    &quot;&quot;&quot;    Helper function for get_message_payload_stock method.     Used to convert a string into a slack formatted text block.     args:    ------      string: (str) concatenated string for the top or bottom ranked          stocks&#39; rsi reading    Return:    ------      dictionary containing the correctly formatted text block to be       displayed in slack    &quot;&quot;&quot;    return {&quot;type&quot;: &quot;section&quot;, &quot;text&quot;: {&quot;type&quot;: &quot;mrkdwn&quot;, &quot;text&quot;: string}}  def get_message_payload_stock(self, top_str, btm_str):    &quot;&quot;&quot;    Used to create a message payload to send stock rsi readings    args:    ------      top_str: (str) concatenated string for the top ranked stocks&#39;           rsi readings      bottom_str: (str) concatenated string for the bottom ranked            stocks&#39; rsi readings    Return:    ------      dictionary containing payload (stock rsi readings) to be sent      using Slack&#39;s API    &quot;&quot;&quot;    return {      &quot;channel&quot;: self. channel,      &quot;username&quot;: self. username,      &quot;blocks&quot;: [        self. _get_text_block(top_str),        self. DIVIDER_BLOCK,        self. _get_text_block(btm_str)      ],    }  def get_message_payload(self, string):    &quot;&quot;&quot;    Used to create a message payload to send simple text messages    args:    ------      string: (str) string to be sent using Slack&#39;s API    Return:    ------      dictionary containing payload (simple text messages) to be sent      using Slack&#39;s API.     &quot;&quot;&quot;    return {      &quot;channel&quot;: self. channel,      &quot;username&quot;: self. username,      &quot;text&quot;: string    }    Retrieving the RSI readings - Overbought or Oversold?&#182;: RSI was developed as a momentum osciallator that measures the speed and change of price movements. The index mainly osciallates between 0 to 100 and a stock is considered as overbought when it is above 70 and oversold when below 30. This is a relatively simple indicator and you can always substitute RSI for other indicators. Our aim with get_stocks_rsi is to retrieve a dataframe with stock names, their RSI readings and whether they are within the overbought (&gt;70), oversold (&lt;30), normal ranges. I have illustrated the output of this function using 10 stocks selected from a pool of companies.       from src. stock import get_sp500_stocks_wiki, get_sp500_stocks_file, \           filter_stocks_industry, get_stock_price, \           get_stock_price_df, get_rsi          def get_stocks_rsi(rsi_n=14, stocks_n=100, file_path=&#39;. /data/sp500_stocks. csv&#39;,          ind_excld=[&#39;Health Care&#39;, &#39;Utilities&#39;, &#39;Energy&#39;]):  &quot;&quot;&quot;  Calculates the Relative Strength Index (RSI) for a group of stocks  args:  ------    rsi_n: (list) size of rsi look-back period    stocks_n: (int) number of stocks to retrieve the rsi for    file_path (str): path leading to csv file of S&amp;P500 component              stocks    ind_excld: (list) GICS Sector industries to be excluded  Return:  ------    df_rsi: (pd. DataFrame) returns the rsi reading for the list of         stocks and whether the 30/70 level has been breached  &quot;&quot;&quot;  sp500_stocks_df = get_sp500_stocks_file(file_path=file_path)  sp500_stocks_df_excld = filter_stocks_industry(sp500_stocks_df,                          ind_excld=ind_excld)    sp500_stocks_df_excld = sp500_stocks_df_excld. head(stocks_n)  info, symbols = get_stock_price(sp500_stocks_df_excld)  sp500_stocks_price_df = get_stock_price_df(info, symbols)  symbols = sp500_stocks_price_df[&#39;Symbol&#39;]. unique()  rsi_l = []  status_l = []  for s in symbols:    s_df = sp500_stocks_price_df[sp500_stocks_price_df[&#39;Symbol&#39;] == s]    closep = np. array(s_df[&#39;Close&#39;]. tolist())    closep = closep. astype(np. float)    rsi = get_rsi(closep, n=rsi_n)    if rsi[-1] &gt;=70:      status = &#39;Above 70&#39;    elif rsi[-1] &lt;= 30:      status = &#39;Below 30&#39;    else:      status = &#39;Normal&#39;    rsi_l. append(round(rsi[-1], 1))    status_l. append(status)  df_rsi = pd. DataFrame(zip(symbols, rsi_l, status_l),             columns=[&#39;Symbols&#39;, &#39;RSI&#39;, &#39;Status&#39;])  return df_rsi          df_rsi = get_stocks_rsi(rsi_n=14, stocks_n=10,             file_path=&#39;. /data/sp500_stocks. csv&#39;,             ind_excld=[&#39;Health Care&#39;, &#39;Utilities&#39;, &#39;Energy&#39;])df_rsi. head(10)           Symbols   RSI   Status         0   MMM   49. 6   Normal       1   ACN   53. 1   Normal       2   ATVI   66. 0   Normal       3   ADBE   39. 4   Normal       4   AMD   29. 1   Below 30       5   AAP   44. 5   Normal       6   AFL   35. 0   Normal       7   APD   42. 2   Normal       8   AKAM   67. 4   Normal       9   ALK   42. 9   Normal     Let's breakdown the get_stocks_rsi. First we retrieve a dataframe of the S&amp;P500 component stocks. Thankfully we have already saved it in a csv file earlier and all we need to do is to read the file.       def get_sp500_stocks_file(file_path=None):  &quot;&quot;&quot;  Reads a csv file containing the wikipedia S&amp;P500 component stocks table  args:  ------    file_path: (str) path leading to the csv file  Return:  ------    df: (pd. DataFrame) a copy of the wikipedia table  &quot;&quot;&quot;  df = pd. read_csv(file_path)  return df          sp500_stocks_df = get_sp500_stocks_file(file_path=&quot;. /data/sp500_stocks. csv&quot;)sp500_stocks_df[[&#39;Ticker&#39;, &#39;Security&#39;, &#39;GICS&#39; ]]. head(10)           Ticker   Security   GICS         0   MMM   3M Company   Industrials       1   ABT   Abbott Laboratories   Health Care       2   ABBV   AbbVie Inc.    Health Care       3   ABMD   ABIOMED Inc   Health Care       4   ACN   Accenture plc   Information Technology       5   ATVI   Activision Blizzard   Communication Services       6   ADBE   Adobe Inc.    Information Technology       7   AMD   Advanced Micro Devices Inc   Information Technology       8   AAP   Advance Auto Parts   Consumer Discretionary       9   AES   AES Corp   Utilities     You can exclude any industries that you are not interested in. In this scenario, I have excluded companies from the Health Care, Utilities and Energy industries.       def filter_stocks_industry(df, ind_excld=[]):  &quot;&quot;&quot;  Filters a dataframe based on the GICS industries  args:  ------    df: (pd. DataFrame) a copy of the wikipedia table    ind_excld: (list) GICS industries to be excluded  Return:  ------    df_excld: (pd. DataFrame) filtered dataframe  &quot;&quot;&quot;  df_excld = df[~df[&#39;GICS&#39;]. isin(ind_excld)]  return df_excld          sp500_stocks_df_excld = filter_stocks_industry(sp500_stocks_df,                        ind_excld=[&#39;Health Care&#39;,                             &#39;Utilities&#39;,                             &#39;Energy&#39;])sp500_stocks_df_excld[[&#39;Ticker&#39;, &#39;Security&#39;, &#39;GICS&#39; ]]. head(10)           Ticker   Security   GICS         0   MMM   3M Company   Industrials       4   ACN   Accenture plc   Information Technology       5   ATVI   Activision Blizzard   Communication Services       6   ADBE   Adobe Inc.    Information Technology       7   AMD   Advanced Micro Devices Inc   Information Technology       8   AAP   Advance Auto Parts   Consumer Discretionary       10   AFL   AFLAC Inc   Financials       12   APD   Air Products &amp; Chemicals Inc   Materials       13   AKAM   Akamai Technologies Inc   Information Technology       14   ALK   Alaska Air Group Inc   Industrials     Now that we have the stocks that we would like to focus on, it is time for us to get the historical stock price for each of them. We will use the first 10 stocks of our dataframe for illustration. As Alpha Vantage limits the number of API calls per minute (5 calls/minute), we will tell the program to sleep and retrieve the next set of stocks at intervals of 65 seconds.       def get_stock_price(df_excld):  &quot;&quot;&quot;  Retrieves the daily stock price from a dataframe of stocks and their  respective tickers  args:  ------    df_excld: (pd. DataFrame) filtered dataframe of stocks containing only         stocks from selected industries  Return:  ------    info: (list) a complete history of stocks&#39; pricing/volume information     symbols: (list) stock tickers  &quot;&quot;&quot;  ts = TimeSeries(ALPHA_VANTAGE_KEY)  info = []  symbols = []  counter = 0  for t in df_excld[&#39;Ticker&#39;]:    if counter % 5 == 0:      time. sleep(65)    i, m = ts. get_daily(symbol=t, outputsize=&#39;full&#39;)    info. append(i)    symbols. append(m[&#39;2. Symbol&#39;])    counter += 1  return info, symbols          sp500_stocks_df_excld = sp500_stocks_df_excld. head(10)info, symbols = get_stock_price(sp500_stocks_df_excld)    We have managed to obtain the price and volume information for our stocks. Let's zoom in and look at MMM's (first ticker) pricing and volume information.       info[0][&#39;2020-02-28&#39;]  {&#39;1. open&#39;: &#39;154. 0900&#39;, &#39;2. high&#39;: &#39;156. 7200&#39;, &#39;3. low&#39;: &#39;146. 0000&#39;, &#39;4. close&#39;: &#39;149. 2400&#39;, &#39;5. volume&#39;: &#39;11498521&#39;}  And these are the stocks that we have extracted the information for.       symbols  [&#39;MMM&#39;, &#39;ACN&#39;, &#39;ATVI&#39;, &#39;ADBE&#39;, &#39;AMD&#39;, &#39;AAP&#39;, &#39;AFL&#39;, &#39;APD&#39;, &#39;AKAM&#39;, &#39;ALK&#39;]  Now that we have retrieved all the information we need, let's convert it into a dataframe for better visualization       def get_stock_price_df(info, symbols):  &quot;&quot;&quot;  Converts pricing/volume information and the stocks symbols into  a dataframe  args:  ------    info: (list) a complete history of stocks&#39; pricing/volume information     symbols: (list) stock tickers  Return:  ------    df_full: (pd. DataFrame) consists of stock tickers their pricing/volume         information  &quot;&quot;&quot;  df_l = []  for num, i in enumerate(info):    df = pd. DataFrame. from_dict(i, orient=&#39;index&#39;)    df[&#39;Symbol&#39;] = symbols[num]    df_l. append(df)  df_full = pd. concat(df_l)  df_full = df_full. rename(columns={&#39;1. open&#39;: &#39;Open&#39;,                   &#39;2. high&#39;: &#39;High&#39;,                   &#39;3. low&#39;: &#39;Low&#39;,                   &#39;4. close&#39;: &#39;Close&#39;,                   &#39;5. volume&#39;: &#39;Volume&#39;})  return df_full          sp500_stocks_price_df = get_stock_price_df(info, symbols)sp500_stocks_price_df. head(5)           Open   High   Low   Close   Volume   Symbol         2020-03-03   152. 4400   154. 0000   144. 4400   145. 2400   8253737   MMM       2020-03-02   151. 3400   153. 4300   148. 3700   153. 0200   8021045   MMM       2020-02-28   154. 0900   156. 7200   146. 0000   149. 2400   11498521   MMM       2020-02-27   151. 2300   155. 4300   149. 0000   150. 1600   8217960   MMM       2020-02-26   149. 5700   151. 8200   148. 0900   148. 9600   5151670   MMM     Finally, we can feed the stock prices into get_rsi to obtain the RSI readings.       def get_rsi(prices, n=14):  &quot;&quot;&quot;  Calculates the Relative Strength Index (RSI) for a stock  Credits: sentdex - https://www. youtube. com/watch?v=4gGztYfp3ck  args:  ------    prices: (list) prices for a stock    n: (int) size of RSI look-back period  Return:  ------    rsi: (float): momentum indicator that measures the magnitude of recent           price changes to evaluate overbought or oversold            conditions    https://www. investopedia. com/terms/r/rsi. asp  &quot;&quot;&quot;  deltas = np. diff(prices)  seed = deltas[:n+1]  up = seed[seed &gt;= 0]. sum()/n  down = -seed[seed &lt; 0]. sum()/n  rs = up/down  rsi = np. zeros_like(prices)  rsi[:n] = 100. - 100. /(1. + rs)  for i in range(n, len(prices)):    delta = deltas[i-1]    if delta &gt; 0:      upval = delta      downval = 0.     else:      upval = 0.       downval = -delta    up = (up*(n-1) + upval)/n    down = (down*(n-1) + downval)/n    rs = up/down    rsi[i] = 100. - 100. /(1. +rs)  return rsi    Converting our RSI readings from a dataframe to concatenated strings&#182;: Unfortunately, as much as we want to, we are not able to send the whole dataframe we have created above as a message to our Slack channel. One workaround for this is to extract the stock tickers and RSI readings as strings before concatenating them together and send them to our Slack channel.        def get_rsi_string(df_rsi, head_n=20, tail_n=20):  &quot;&quot;&quot;  Converts the RSI readings into strings to be displayed in Slack  args:  ------    df_rsi: (pd. DataFrame) the rsi readings for a list of         stocks and whether the 30/70 levels have been breached    head_n: (int) number of top ranked stocks (based on rsi) reading        to be displayed in Slack    tail_n: (int) number of bottom ranked stocks (based on rsi) reading         to be displayed in Slack  Return:  ------    top_str: (str) concatenated string for top ranked stocks&#39; rsi         reading    btm_str: (str) concatenated string for bottom ranked stocks&#39; rsi         reading  &quot;&quot;&quot;  df_rsi = df_rsi. sort_values(&#39;RSI&#39;, ascending=False)  df_top = df_rsi. head(head_n)  df_btm = df_rsi. tail(tail_n)  top_symbols = df_top[&#39;Symbols&#39;]. tolist()  btm_symbols = df_btm[&#39;Symbols&#39;]. tolist()  top_rsi = df_top[&#39;RSI&#39;]. tolist()  btm_rsi = df_btm[&#39;RSI&#39;]. tolist()  top_l = list(zip(top_symbols, top_rsi))  btm_l = list(zip(btm_symbols, btm_rsi))  top_str = &quot;&quot;  for el in top_l:    top_str = top_str + str(el[0]) + &quot; &quot; + str(el[1]) + &quot;\n&quot;  btm_str = &quot;&quot;  for el in btm_l:    btm_str = btm_str + str(el[0]) + &quot; &quot; + str(el[1]) + &quot;\n&quot;  return top_str, btm_str          top_str, btm_str = get_rsi_string(df_rsi, head_n=5, tail_n=5)    This is the concatenated string for the top 5/ bottom 5 ranked stocks (based on RSI readings). The escape sequence  \n  will help to display each stock on a new line when viewed on the Slack channel.       top_str  &#39;AKAM 67. 4\nATVI 66. 0\nACN 53. 1\nMMM 49. 6\nAAP 44. 5\n&#39;        btm_str  &#39;ALK 42. 9\nAPD 42. 2\nADBE 39. 4\nAFL 35. 0\nAMD 29. 1\n&#39;  We're almost there! Let's integrate our code with Slack's API&#182;: For us to send the concatenated string to our Slack Channel, Slack requires us to format our strings in the form of a  block  that contains other required meta information. We will be using the  _get_text_block  helper to help us do just that.       def _get_text_block(self, string):  &quot;&quot;&quot;  Helper function for get_message_payload_stock.   Used to convert a string into a slack formatted text block.   args:  ------    string: (str) concatenated string for the top or bottom ranked         stocks&#39; rsi reading  Return:  ------    dictionary containing the correctly formatted text block to be    displayed in slack  &quot;&quot;&quot;  return {&quot;type&quot;: &quot;section&quot;, &quot;text&quot;: {&quot;type&quot;: &quot;mrkdwn&quot;, &quot;text&quot;: string}}    We can then piece together our  text_block  with other user specific information to create our payload. Additional information that are required: channel: ID of the channel that we are sending this message tousername: The name of our slackbotWe will use the following two methods to send two types of payload: get_message_payload_stock: used to send our RSI readings to the Slack channel. This payload includes a divider block that separates the top and bottom ranked RSI readings. get_message_paylaod: used to send simple texts.       def get_message_payload_stock(self, top_str, btm_str):  &quot;&quot;&quot;  Used to create a message payload to send stock rsi readings  args:  ------    top_str: (str) concatenated string for the top ranked stocks&#39;         rsi readings    bottom_str: (str) concatenated string for the bottom ranked stocks&#39;          rsi readings  Return:  ------    dictionary containing payload (stock rsi readings) to be sent using    Slack&#39;s API  &quot;&quot;&quot;  return {    &quot;channel&quot;: self. channel,    &quot;username&quot;: self. username,    &quot;blocks&quot;: [      self. _get_text_block(top_str),      self. DIVIDER_BLOCK,      self. _get_text_block(btm_str)    ],  }          def get_message_payload(self, string):  &quot;&quot;&quot;  Used to create a message payload to send simple text messages  args:  ------    string: (str) string to be sent using Slack&#39;s API  Return:  ------    dictionary containing payload (simple text messages) to be sent    using Slack&#39;s API  &quot;&quot;&quot;  return {    &quot;channel&quot;: self. channel,    &quot;username&quot;: self. username,    &quot;text&quot;: string  }    Wait a minute. . . &#182;: Before I demonstrate how we can use the methods to send our payloads to Slack, I would like to introduce get_fed_holidays which will help us retrieve the days that the US market is closed. When the market is closed, we are not able to retrieve new stock information, hence there is no need for us to retrieve new RSI readings. During periods like this, we can give our bot a break and instead notify us with a message 'Market closed, US Federal holiday'.       def get_fed_holidays(start_date, end_date):  &quot;&quot;&quot;  Retrieve a dataframe outlining the days that the US market is closed  args:  ------    start_date: (str) start date for the period in focus    end_date: (str) end date for the period in focus  Return:  ------    df_holiday: (pd. DataFrame) returns the days that are US market holidays  &quot;&quot;&quot;  dr = pd. date_range(start=start_date, end=end_date)  df = pd. DataFrame()  df[&#39;Date&#39;] = dr  cal = calendar()  holidays = cal. holidays(start=dr. min(), end=dr. max())  df[&#39;Holiday&#39;] = df[&#39;Date&#39;]. isin(holidays)  df_holiday = df[df[&#39;Holiday&#39;] == True]  return df_holiday    Ok now let us see how we can send simple text messages and our RSI readings sent to Slack. Let's first instantiate the class with our channel ID       s = Smartie(CHANNEL_ID)    If it is a US Federal holiday, the following payload will be sent to the Slack channel. . . .       message = s. get_message_payload(&#39;Market closed, US Federal holiday&#39;)message  {&#39;channel&#39;: &#39;CU560GVCG&#39;, &#39;text&#39;: &#39;Market closed, US Federal holiday&#39;, &#39;username&#39;: &#39;smartie&#39;}  . . . else we will send the RSI readings.       message = s. get_message_payload_stock(top_str, btm_str)message  {&#39;blocks&#39;: [{&#39;text&#39;: {&#39;text&#39;: &#39;AKAM 67. 4\nATVI 66. 0\nACN 53. 1\nMMM 49. 6\nAAP 44. 5\n&#39;,  &#39;type&#39;: &#39;mrkdwn&#39;},  &#39;type&#39;: &#39;section&#39;}, {&#39;type&#39;: &#39;divider&#39;}, {&#39;text&#39;: {&#39;text&#39;: &#39;ALK 42. 9\nAPD 42. 2\nADBE 39. 4\nAFL 35. 0\nAMD 29. 1\n&#39;,  &#39;type&#39;: &#39;mrkdwn&#39;},  &#39;type&#39;: &#39;section&#39;}], &#39;channel&#39;: &#39;CU560GVCG&#39;, &#39;username&#39;: &#39;smartie&#39;}  Sending our first message!&#182;Let's put everything we have worked on so far and see how the messages looks like on our Slack channel!       import slackslack_web_client = slack. WebClient(token=SLACK_BOT_TOKEN)          response = slack_web_client. chat_postMessage(**message)response  &lt;slack. web. slack_response. SlackResponse at 0x7f70e6eb45c0&gt;        import logginglogger = logging. getLogger()logger. setLevel(logging. DEBUG)s = Smartie(CHANNEL_ID)logger. info(&#39;Getting fed holidays&#39;)range_start_date = &#39;2020-01-01&#39;range_end_date = &#39;2020-12-31&#39;fed_holiday = get_fed_holidays(start_date=range_start_date,                end_date=range_end_date)if str(datetime. datetime. now(). date()) in fed_holiday:  logger. info(&#39;It is a Holiday&#39;)  message = s. get_message_payload(&#39;Market closed, US Federal holiday&#39;)else:  logger. info(&#39;It is not a Holiday&#39;)  df_rsi = s. get_stocks_rsi(rsi_n=14, stocks_n=10)  top_str, btm_str = s. get_rsi_string(df_rsi, head_n=5, tail_n=5)  message = s. get_message_payload_stock(top_str, btm_str)logger. info(&#39;Posting on Slack&#39;)response = slack_web_client. chat_postMessage(**message)    Great! You should have received a message like the one below in your channel (that is if isn't a US Federal holiday).  Deployment&#182;Dockerfile&#182;: The Dockerfile outlines a set of instructions/commands needed to build a docker image. This can include simple commands such as COPY which adds files from a source on your computer into the Docker image. We will use the Miniconda base image which comes with Python.       # our base imageFROM continuumio/miniconda3# update essential packagesRUN apt update &amp;&amp; \  apt -y install bzip2 curl gcc ssh rsync git vim cron &amp;&amp; \  apt-get clean# creating our conda environmentARG CONDA_ENV_FILEARG CONDA_PATH=&quot;/root/miniconda3/bin&quot;ARG CONDA_BIN=&quot;$CONDA_PATH/conda&quot;COPY $CONDA_ENV_FILE $CONDA_ENV_FILEENV SHELL /bin/bashRUN conda install nb_condaENV PATH /root/miniconda3/envs/stock_screener/bin:$CONDA_PATH:$PATH# update the environmentCOPY conda. yml . RUN conda env update -n stock_screener --file . /conda. yml# adding our environment variables for Cron job to workRUN printenv &gt;&gt; /etc/environment# allow log messages to be printed in interactive terminalENV PYTHONUNBUFFERED 1# run shell scriptRUN chmod +x . /run. shENTRYPOINT [&quot;. /run. sh&quot;]    Conda. yml&#182;: The conda. yml file will be used to upgrade the python version and install any package dependencies that we need in our conda environment.       channels: - defaultsdependencies: - python=3. 6. 7 - pip=19. 0. 3 - nb_conda - pip:  - alpha-vantage==2. 1. 3  - beautifulsoup4==4. 8. 2  - pandas==1. 0. 1  - numpy==1. 18. 1  - slack==0. 0. 2  - slackclient==2. 5. 0  - slackeventsapi==2. 1. 0  - websocket-client==0. 57. 0    run. sh&#182;: For our log messages to be printed out in the interactive terminal, we will need to create a softlink /var/log/cron. log to /proc/1/fd/1. This will allow standard output and error streams that are passed to the softlink /var/log/cron. log and be directed to /proc/1/fd/1 which can then be viewed in the interactive terminal. ln -sf /proc/1/fd/1 /var/log/cron. log As we would like the app to send us updates on a periodic basis, we will have to tell the server to run our code repeatedly. To do this, we can use the Cron service which is available on our server by listing down the things we need the Cron service to work on in the /etc/crontab file. The   s denote the schedule that the code will run at. As an example,  0 1    will mean that the code will run every day at 1am. Currently I have chosen to schedule the script to run every 5 minutes for testing  5   . The picture below illustrates what each  *  represents. echo '5 * * * * root cd / &amp;&amp; /opt/conda/envs/stock_screener/bin/python . /app. py &gt;&gt; /var/log/cron. log' &gt; /etc/crontab       #!/bin/bashprintenv &gt; /etc/default/localeservice cron startecho &#39;Smartie is ready for action!&#39;ln -sf /proc/1/fd/1 /var/log/cron. logecho &#39;5 * * * * root cd / &amp;&amp; /opt/conda/envs/stock_screener/bin/python . /app. py &gt;&gt; /var/log/cron. log&#39; &gt; /etc/crontabtail -f /var/log/cron. log    env. list (you will need to create this)&#182;: Remember the credentials that we painstakingly created and saved in credentials. py? You will need to create a env. list file and copy all your credential over. Just that this time, the double quotes    can be omitted from the env. list file. You can then save the file anywhere on your local computer but remember the path that you saved it under.       # You should have something similar in env. listSLACK_API_TOKEN=xoxp-945736515923-959414305302. . . . CHANNEL_ID=CU. . . SLACK_BOT_TOKEN=xoxb-945736515923-957048941172. . . . . SLACK_SIGNING_SECRET=88a3424d. . . . . ALPHA_VANTAGE_KEY=E1UR. . . .     Creating the docker image on docker hub&#182;: First let's build the Docker image from the Dockerfile. You will need to run the following code on your terminal, in the same directory as the Dockerfile. Replace  kennethwang92  with your Docker ID.       docker build -t kennethwang92/stock_screener     After building, you can tag it with a name eg. latest and push the image to docker hub. Replace 0e5574283393 with your image ID. By default your image would have been tagged with  latest , you can substitute it with another label if you prefer. In this example, let's label the image as  demo        docker tag 0e5574283393 kennethwang92/stock_screener:demo    Login to docker hub on your terminal. Key in your username and password when prompted.       docker login docker. io    Push the image to docker hub.       docker push kennethwang92/stock_screener:demo     Deploying on a Digital Ocean Server (droplet)&#182;Now that we have pushed the image to Docker hub, we can create a server using Digital Ocean for us to deploy the container. Below is a step-by-step guide on how to create a server (Digital Ocean calls it a droplet). Creating a server&#182;: Set up an account with Digital Ocean here Create a project Create a droplet Select ubuntu Choose a plan Select a datacenter Create ssh. Click on  New SSH Key  and follow the instructions  Click on create droplet Select droplet Save the IP address as you will have to use it in a moment.  Connecting to the server and building the docker container&#182;: First let's copy the env. list file that you saved in your local computer into the server. In this case, I have saved it in my Desktop.       # copy the env. list file from your local computer into the serverscp -r -i ~/. ssh/id_rsa . /env. list root@[ip address]:~     To connect to the server, you will have to insert the ip address you have copied previously. Type  yes  if you are prompted  Are you sure you want to continue connecting        ssh -i ~/. ssh/id_rsa root@[ip address]     While in the server, type the following commands       # to update apt-get command-line tool for handling packagesapt-get update          # install dockerapt install docker. io           # download image from Docker Hubdocker pull kennethwang92/stock_screener:demo          # run the image with our credentials in env. list to create our docker container. # replace ~Desktop/env. list with the path leading to your env. list file. # for my case I have saved the file on my desktop. # replace &quot;kennethwang92&quot; with your Docker ID if you would like to use your own# image. # ensure that you are running this code in the same directory as the env. list# file. docker run -it --env-file . /env. list kennethwang92/stock_screener:demo /bin/bash     And we're done! Check your Slack channel for the messages! Future improvements:&#182;Slack bots are really powerful and by connecting it with python, the possibilities are endless. These are some of the improvements I can think of at the moment: Instead of using RSI,you can substitute the indicator with others that you are interested in. *You can even execute trades through the bot if your broker has an API that you can connect to. Send . png/. jpeg graphs instead of texts? I hope that you liked this article and you find the Slack bot useful. If you have any questions/comments please feel free to reach out to me through Linkedin or email at ken. wangtm@gmail. com "
    }, {
    "id": 5,
    "url": "https://kenneth-wang.github.io/fastpages/jupyter/2020/02/20/test.html",
    "title": "Fastpages Notebook Blog Post",
    "body": "2020/02/20 -           About&#182;This notebook is a demonstration of some of capabilities of fastpages with notebooks. With fastpages you can save your jupyter notebooks into the _notebooks folder at the root of your repository, and they will be automatically be converted to Jekyll compliant blog posts! Front Matter&#182;: Front Matter is a markdown cell at the beginning of your notebook that allows you to inject metadata into your notebook. For example: Setting toc: true will automatically generate a table of contentsSetting badges: true will automatically include GitHub and Google Colab links to your notebook. Setting comments: true will enable commenting on your blog post, powered by utterances. More details and options for front matter can be viewed on the front matter section of the README. Markdown Shortcuts&#182;: put a #hide flag at the top of any cell you want to completely hide in the docs put a #collapse-hide flag at the top of any cell if you want to hide that cell by default, but give the reader the option to show it:              #collapse-hideimport pandas as pdimport altair as alt       put a #collapse-show flag at the top of any cell if you want to show that cell by default, but give the reader the option to hide it:              #collapse-showcars = &#39;https://vega. github. io/vega-datasets/data/cars. json&#39;movies = &#39;https://vega. github. io/vega-datasets/data/movies. json&#39;sp500 = &#39;https://vega. github. io/vega-datasets/data/sp500. csv&#39;stocks = &#39;https://vega. github. io/vega-datasets/data/stocks. csv&#39;flights = &#39;https://vega. github. io/vega-datasets/data/flights-5k. json&#39;       Interactive Charts With Altair&#182;: Charts made with Altair remain interactive.  Example charts taken from this repo, specifically this notebook. Example 1: DropDown&#182;:       # single-value selection over [Major_Genre, MPAA_Rating] pairs# use specific hard-wired values as the initial selected valuesselection = alt. selection_single(  name=&#39;Select&#39;,  fields=[&#39;Major_Genre&#39;, &#39;MPAA_Rating&#39;],  init={&#39;Major_Genre&#39;: &#39;Drama&#39;, &#39;MPAA_Rating&#39;: &#39;R&#39;},  bind={&#39;Major_Genre&#39;: alt. binding_select(options=genres), &#39;MPAA_Rating&#39;: alt. binding_radio(options=mpaa)}) # scatter plot, modify opacity based on selectionalt. Chart(movies). mark_circle(). add_selection(  selection). encode(  x=&#39;Rotten_Tomatoes_Rating:Q&#39;,  y=&#39;IMDB_Rating:Q&#39;,  tooltip=&#39;Title:N&#39;,  opacity=alt. condition(selection, alt. value(0. 75), alt. value(0. 05)))    Example 2: Tooltips&#182;:       alt. Chart(movies). mark_circle(). add_selection(  alt. selection_interval(bind=&#39;scales&#39;, encodings=[&#39;x&#39;])). encode(  x=&#39;Rotten_Tomatoes_Rating:Q&#39;,  y=alt. Y(&#39;IMDB_Rating:Q&#39;, axis=alt. Axis(minExtent=30)), # use min extent to stabilize axis title placement  tooltip=[&#39;Title:N&#39;, &#39;Release_Date:N&#39;, &#39;IMDB_Rating:Q&#39;, &#39;Rotten_Tomatoes_Rating:Q&#39;]). properties(  width=600,  height=400)    Example 3: More Tooltips&#182;:       # select a point for which to provide details-on-demandlabel = alt. selection_single(  encodings=[&#39;x&#39;], # limit selection to x-axis value  on=&#39;mouseover&#39;, # select on mouseover events  nearest=True,  # select data point nearest the cursor  empty=&#39;none&#39;   # empty selection includes no data points)# define our base line chart of stock pricesbase = alt. Chart(). mark_line(). encode(  alt. X(&#39;date:T&#39;),  alt. Y(&#39;price:Q&#39;, scale=alt. Scale(type=&#39;log&#39;)),  alt. Color(&#39;symbol:N&#39;))alt. layer(  base, # base line chart    # add a rule mark to serve as a guide line  alt. Chart(). mark_rule(color=&#39;#aaa&#39;). encode(    x=&#39;date:T&#39;  ). transform_filter(label),    # add circle marks for selected time points, hide unselected points  base. mark_circle(). encode(    opacity=alt. condition(label, alt. value(1), alt. value(0))  ). add_selection(label),  # add white stroked text to provide a legible background for labels  base. mark_text(align=&#39;left&#39;, dx=5, dy=-5, stroke=&#39;white&#39;, strokeWidth=2). encode(    text=&#39;price:Q&#39;  ). transform_filter(label),  # add text labels for stock prices  base. mark_text(align=&#39;left&#39;, dx=5, dy=-5). encode(    text=&#39;price:Q&#39;  ). transform_filter(label),    data=stocks). properties(  width=700,  height=400)    Data Tables&#182;: You can display tables per the usual way in your blog:       movies = &#39;https://vega. github. io/vega-datasets/data/movies. json&#39;df = pd. read_json(movies)# display table with pandasdf[[&#39;Title&#39;, &#39;Worldwide_Gross&#39;,   &#39;Production_Budget&#39;, &#39;IMDB_Rating&#39;]]. head()           Title   Worldwide_Gross   Production_Budget   IMDB_Rating         0   The Land Girls   146083. 0   8000000. 0   6. 1       1   First Love, Last Rites   10876. 0   300000. 0   6. 9       2   I Married a Strange Person   203134. 0   250000. 0   6. 8       3   Let's Talk About Sex   373615. 0   300000. 0   NaN       4   Slam   1087521. 0   1000000. 0   3. 4     Images&#182;: Local Images&#182;: You can reference local images and they will be copied and rendered on your blog automatically.  You can include these with the following markdown syntax: ![](my_icons/fastai_logo. png) Remote Images&#182;: Remote images can be included with the following markdown syntax: ![](https://image. flaticon. com/icons/svg/36/36686. svg) Animated Gifs&#182;: Animated Gifs work, too! ![](https://upload. wikimedia. org/wikipedia/commons/7/71/ChessPawnSpecialMoves. gif) Captions&#182;: You can include captions with markdown images like this: ![](https://www. fast. ai/images/fastai_paper/show_batch. png  Credit: https://www. fast. ai/2020/02/13/fastai-A-Layered-API-for-Deep-Learning/ ) Other Elements&#182;Tweetcards&#182;: Typing &gt; twitter: https://twitter. com/jakevdp/status/1204765621767901185?s=20 will render this:Altair 4. 0 is released! https://t. co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t. co/roXmzcsT58 . . . read on for some highlights. pic. twitter. com/vWJ0ZveKbZ &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 Youtube Videos&#182;: Typing &gt; youtube: https://youtu. be/XfoYk_Z5AkI will render this: Boxes / Callouts&#182;: Typing &gt; Warning: There will be no second warning! will render this:    Warning: There will be no second warning! Typing &gt; Important: Pay attention! It's important. will render this:    Important: Pay attention! It&#8217;s important. Typing &gt; Tip: This is my tip. will render this:    Tip: This is my tip. Typing &gt; Note: Take note of this. will render this:    Note: Take note of this. Typing &gt; Note: A doc link to [an example website: fast. ai](https://www. fast. ai/) should also work fine. will render in the docs:    Note: A doc link to an example website: fast. ai should also work fine. "
    }, {
    "id": 6,
    "url": "https://kenneth-wang.github.io/fastpages/markdown/2020/01/14/test-markdown-post.html",
    "title": "Example Markdown Post",
    "body": "2020/01/14 - Basic setup: Jekyll requires blog post files to be named according to the following format: YEAR-MONTH-DAY-filename. md Where YEAR is a four-digit number, MONTH and DAY are both two-digit numbers, and filename is whatever file name you choose, to remind yourself what this post is about. . md is the file extension for markdown files. The first line of the file should start with a single hash character, then a space, then your title. This is how you create a “level 1 heading” in markdown. Then you can create level 2, 3, etc headings as you wish but repeating the hash character, such as you see in the line ## File names above. Basic formatting: You can use italics, bold, code font text, and create links. Here’s a footnote 1. Here’s a horizontal rule: Lists: Here’s a list:  item 1 item 2And a numbered list:  item 1 item 2Boxes and stuff:  This is a quotation    You can include alert boxes…and…    You can include info boxesImages: Code: General preformatted text: # Do a thingdo_thing()Python code and output: # Prints '2'print(1+1)2Tables:       Column 1   Column 2         A thing   Another thing   Tweetcards: Altair 4. 0 is released! https://t. co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t. co/roXmzcsT58 . . . read on for some highlights. pic. twitter. com/vWJ0ZveKbZ &mdash; Jake VanderPlas (@jakevdp) December 11, 2019Footnotes:       This is the footnote.  &#8617;    "
    }];

var idx = lunr(function () {
    this.ref('id')
    this.field('title')
    this.field('body')
    this.metadataWhitelist = ['position']

    documents.forEach(function (doc) {
        this.add(doc)
    }, this)
});
function lunr_search(term) {
    document.getElementById('lunrsearchresults').innerHTML = '<ul></ul>';
    if(term) {
        document.getElementById('lunrsearchresults').innerHTML = "<p>Search results for '" + term + "'</p>" + document.getElementById('lunrsearchresults').innerHTML;
        //put results on the screen.
        var results = idx.search(term);
        if(results.length>0){
            //console.log(idx.search(term));
            //if results
            for (var i = 0; i < results.length; i++) {
                // more statements
                var ref = results[i]['ref'];
                var url = documents[ref]['url'];
                var title = documents[ref]['title'];
                var body = documents[ref]['body'].substring(0,160)+'...';
                document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML + "<li class='lunrsearchresult'><a href='" + url + "'><span class='title'>" + title + "</span><br /><span class='body'>"+ body +"</span><br /><span class='url'>"+ url +"</span></a></li>";
            }
        } else {
            document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = "<li class='lunrsearchresult'>No results found...</li>";
        }
    }
    return false;
}